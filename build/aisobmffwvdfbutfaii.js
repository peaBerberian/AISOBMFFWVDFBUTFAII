/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/isobmff-inspector/dist/bundle.js":
/*!*******************************************************!*\
  !*** ./node_modules/isobmff-inspector/dist/bundle.js ***!
  \*******************************************************/
/***/ (function(module) {

eval("(function (global, factory) {\n   true ? module.exports = factory() :\n  0;\n})(this, (function () { 'use strict';\n\n  /**\n   * Translate groups of 2 big-endian bytes to Integer (from 0 up to 65535).\n   * @param {TypedArray} bytes\n   * @param {Number} off - The offset (from the start of the given array)\n   * @returns {Number}\n   */\n  function be2toi(bytes, off) {\n    return (bytes[0 + off] << 8) + bytes[1 + off];\n  }\n  /**\n   * Translate groups of 3 big-endian bytes to Integer.\n   * @param {TypedArray} bytes\n   * @param {Number} off - The offset (from the start of the given array)\n   * @returns {Number}\n   */\n\n\n  function be3toi(bytes, off) {\n    return bytes[0 + off] * 0x0010000 + bytes[1 + off] * 0x0000100 + bytes[2 + off];\n  }\n  /**\n   * Translate groups of 4 big-endian bytes to Integer.\n   * @param {TypedArray} bytes\n   * @param {Number} off - The offset (from the start of the given array)\n   * @returns {Number}\n   */\n\n\n  function be4toi(bytes, off) {\n    return bytes[0 + off] * 0x1000000 + bytes[1 + off] * 0x0010000 + bytes[2 + off] * 0x0000100 + bytes[3 + off];\n  }\n  /**\n   * Translate groups of 4 big-endian bytes to Integer.\n   * @param {TypedArray} bytes\n   * @param {Number} off - The offset (from the start of the given array)\n   * @returns {Number}\n   */\n\n\n  function be5toi(bytes, off) {\n    return bytes[0 + off] * 0x100000000 + bytes[1 + off] * 0x001000000 + bytes[2 + off] * 0x000010000 + bytes[3 + off] * 0x000000100 + bytes[4 + off];\n  }\n  /**\n   * Translate groups of 8 big-endian bytes to Integer.\n   * @param {TypedArray} bytes\n   * @param {Number} off - The offset (from the start of the given array)\n   * @returns {Number}\n   */\n\n\n  function be8toi(bytes, off) {\n    return (bytes[0 + off] * 0x1000000 + bytes[1 + off] * 0x0010000 + bytes[2 + off] * 0x0000100 + bytes[3 + off]) * 0x100000000 + bytes[4 + off] * 0x1000000 + bytes[5 + off] * 0x0010000 + bytes[6 + off] * 0x0000100 + bytes[7 + off];\n  }\n\n  function bytesToHex(uint8arr, off, nbBytes) {\n    if (!uint8arr) {\n      return \"\";\n    }\n\n    var arr = uint8arr.slice(off, nbBytes + off);\n    var hexStr = \"\";\n\n    for (var i = 0; i < arr.length; i++) {\n      var hex = (arr[i] & 0xff).toString(16);\n      hex = hex.length === 1 ? \"0\" + hex : hex;\n      hexStr += hex;\n    }\n\n    return hexStr.toUpperCase();\n  } // XXX TODO test that\n\n\n  function betoa(uint8arr, off, nbBytes) {\n    if (!uint8arr) {\n      return \"\";\n    }\n\n    var arr = uint8arr.slice(off, nbBytes + off);\n    return String.fromCharCode.apply(String, arr);\n  }\n\n  /**\n   * Create object allowing to easily parse an ISOBMFF box.\n   *\n   * The BufferReader saves in its state the current offset after each method\n   * call, allowing to easily parse contiguous bytes in box parsers.\n   *\n   * @param {Uint8Array} buffer\n   * @returns {Object}\n   */\n\n  function createBufferReader(buffer) {\n    var currentOffset = 0;\n    return {\n      /**\n       * Returns the following byte, as a number between 0 and 255.\n       * @returns {number}\n       */\n      getNextByte: function getNextByte() {\n        this.getNextBytes(1);\n      },\n\n      /**\n       * Returns the N next bytes, as an Uint8Array\n       * @param {number} nb\n       * @returns {Uint8Array}\n       */\n      getNextBytes: function getNextBytes(nb) {\n        if (this.getRemainingLength() < nb) {\n          return;\n        }\n\n        currentOffset += nb;\n        return buffer.slice(0, nb);\n      },\n\n      /**\n       * Returns the N next bytes, as a single number.\n       *\n       * /!\\ only work for now for 1, 2, 3, 4, 5 or 8 bytes.\n       * TODO Define a more global solution.\n       *\n       * /!\\ Depending on the size of the number, it may be larger than JS'\n       * limit.\n       *\n       * @param {number} nb\n       * @returns {number}\n       */\n      bytesToInt: function bytesToInt(nbBytes) {\n        if (this.getRemainingLength() < nbBytes) {\n          return;\n        }\n\n        var res;\n\n        switch (nbBytes) {\n          case 1:\n            res = buffer[currentOffset];\n            break;\n\n          case 2:\n            res = be2toi(buffer, currentOffset);\n            break;\n\n          case 3:\n            res = be3toi(buffer, currentOffset);\n            break;\n\n          case 4:\n            res = be4toi(buffer, currentOffset);\n            break;\n\n          case 5:\n            res = be5toi(buffer, currentOffset);\n            break;\n\n          case 8:\n            res = be8toi(buffer, currentOffset);\n            break;\n\n          default:\n            throw new Error(\"not implemented yet.\");\n        }\n\n        currentOffset += nbBytes;\n        return res;\n      },\n\n      /**\n       * Returns the N next bytes into a string of Hexadecimal values.\n       * @param {number}\n       * @returns {string}\n       */\n      bytesToHex: function bytesToHex$1(nbBytes) {\n        if (this.getRemainingLength() < nbBytes) {\n          return;\n        }\n\n        var res = bytesToHex(buffer, currentOffset, nbBytes);\n\n        currentOffset += nbBytes;\n        return res;\n      },\n\n      /**\n       * Returns the N next bytes into a string.\n       * @param {number}\n       * @returns {string}\n       */\n      bytesToASCII: function bytesToASCII(nbBytes) {\n        if (this.getRemainingLength() < nbBytes) {\n          return;\n        }\n\n        var res = betoa(buffer, currentOffset, nbBytes);\n        currentOffset += nbBytes;\n        return res;\n      },\n\n      /**\n       * Returns the total length of the buffer\n       * @returns {number}\n       */\n      getTotalLength: function getTotalLength() {\n        return buffer.length;\n      },\n\n      /**\n       * Returns the length of the buffer which is not yet parsed.\n       * @returns {number}\n       */\n      getRemainingLength: function getRemainingLength() {\n        return Math.max(0, buffer.length - currentOffset);\n      },\n\n      /**\n       * Returns true if this buffer is entirely parsed.\n       * @returns {boolean}\n       */\n      isFinished: function isFinished() {\n        return buffer.length <= currentOffset;\n      }\n    };\n  }\n\n  var dinf = {\n    name: \"Data Information Box\",\n    description: \"Objects that declare the location of the media information in a track.\",\n    container: true\n  };\n\n  var dref = {\n    name: \"Data Reference Box\",\n    description: \"\",\n    container: true,\n    parser: function parser(reader) {\n      var version = reader.bytesToInt(1);\n      var flags = reader.bytesToInt(3);\n\n      if (version !== 0) {\n        throw new Error(\"invalid version\");\n      }\n\n      if (flags !== 0) {\n        throw new Error(\"invalid flags\");\n      }\n\n      var entry_count = reader.bytesToInt(4);\n      return {\n        version: version,\n        flags: flags,\n        entry_count: entry_count\n      };\n    }\n  };\n\n  var edts = {\n    name: \"Edit Box\",\n    description: \"Maps the presentation time‐line to the media time‐line as it is stored in the file.\",\n    container: true\n  };\n\n  var free = {\n    name: \"Free Space Box\",\n    description: \"This box can be completely ignored\"\n  };\n\n  var ftyp = {\n    name: \"File Type Box\",\n    description: \"File type and compatibility\",\n    content: [{\n      /* name: \"major brand\", */\n      // optional name\n      key: \"major_brand\",\n      description: \"Brand identifier.\"\n    }, {\n      key: \"minor_version\",\n      description: \"informative integer for the minor version of the major brand\"\n    }, {\n      key: \"compatible_brands\",\n      description: \"List of brands\"\n    }],\n    parser: function parser(reader) {\n      var len = reader.getTotalLength();\n      var major_brand = reader.bytesToASCII(4);\n      var minor_version = reader.bytesToInt(4);\n      var compatArr = [];\n\n      for (var i = 8; i < len; i += 4) {\n        compatArr.push(reader.bytesToASCII(4));\n      }\n\n      return {\n        major_brand: major_brand,\n        minor_version: minor_version,\n        compatible_brands: compatArr.join(\", \")\n      };\n    }\n  };\n\n  var hdlr = {\n    name: \"Handler Reference Box\",\n    description: \"This box within a Media Box declares media type of the track, \" + \"and thus the process by which the media‐data in the track is presented\",\n    parser: function parser(r) {\n      var ret = {\n        version: r.bytesToInt(1),\n        flags: r.bytesToInt(3),\n        pre_defined: r.bytesToInt(4),\n        handler_type: r.bytesToInt(4),\n        reserved: [r.bytesToInt(4), r.bytesToInt(4), r.bytesToInt(4)]\n      };\n      var remaining = r.getRemainingLength();\n      ret.name = \"\";\n\n      while (remaining--) {\n        ret.name += String.fromCharCode(parseInt(r.bytesToInt(1), 10));\n      }\n\n      return ret;\n    }\n  };\n\n  // TODO\n  var iods = {\n    name: \"Initial Object Descriptor Box\"\n  };\n\n  var leva = {\n    name: \"Level Assignment Box\",\n    // TODO\n    parser: function parser(reader) {\n      var version = reader.bytesToInt(1);\n      var flags = reader.bytesToInt(3); // ...\n\n      return {\n        version: version,\n        flags: flags\n      };\n    }\n  };\n\n  var mdat = {\n    name: \"Media Data Box\",\n    description: \"the content's data\"\n  };\n\n  var mdhd = {\n    name: \"Media Header Box\",\n    description: \"The media header declares overall information that is \" + \"media‐independent, and relevant to characteristics of the media in a track.\",\n    parser: function parser(r) {\n      var version = r.bytesToInt(1);\n      var flags = r.bytesToInt(3);\n      var creation_time = r.bytesToInt(version ? 8 : 4);\n      var modification_time = r.bytesToInt(version ? 8 : 4);\n      var timescale = r.bytesToInt(4);\n      var duration = r.bytesToInt(version ? 8 : 4);\n      var next2Bytes = r.bytesToInt(2);\n      var pad = next2Bytes >> 15 & 0x01;\n      var language = [String.fromCharCode((next2Bytes >> 10 & 0x1F) + 0x60), String.fromCharCode((next2Bytes >> 5 & 0x1F) + 0x60), String.fromCharCode((next2Bytes & 0x1F) + 0x60)].join(\"\");\n      var predifined = r.bytesToInt(2);\n      return {\n        version: version,\n        flags: flags,\n        creation_time: creation_time,\n        modification_time: modification_time,\n        timescale: timescale,\n        duration: duration,\n        pad: pad,\n        language: language,\n        predifined: predifined\n      };\n    }\n  };\n\n  var mdia = {\n    name: \"Track Media Structure\",\n    description: \"declare information about the media data within a track.\",\n    container: true\n  };\n\n  var mehd = {\n    name: \"Movie Extends Header Box\",\n    description: \"Provides the overall duration, including fragments, of a \" + \"fragmented movie. If this box is not present, the overall duration must \" + \"be computed by examining each fragment.\",\n    parser: function parser(reader) {\n      var version = reader.bytesToInt(1);\n\n      if (version > 1) {\n        throw new Error(\"invalid version\");\n      }\n\n      var flags = reader.bytesToInt(3);\n      var fragmentDuration = version === 1 ? reader.bytesToInt(8) : reader.bytesToInt(4);\n      return {\n        version: version,\n        flags: flags,\n        \"fragment_duration\": fragmentDuration\n      };\n    }\n  };\n\n  var mfhd = {\n    name: \"Movie Fragment Header Box\",\n    description: \"This box contains just a sequence number (usually starting at 1), as a safety check.\",\n    parser: function parser(r) {\n      return {\n        version: r.bytesToInt(1),\n        flags: r.bytesToInt(3),\n        sequence_number: r.bytesToInt(4)\n      };\n    }\n  };\n\n  var minf = {\n    name: \"Media Information Box\",\n    description: \"This box contains all the objects that declare characteristic information of the media in the track.\",\n    container: true\n  };\n\n  var moof = {\n    name: \"Movie Fragment Box\",\n    description: \"\",\n    container: true\n  };\n\n  var moov = {\n    name: \"Movie Box\",\n    description: \"The movie metadata\",\n    container: true\n  };\n\n  var mvex = {\n    name: \"Movie Extends Box\",\n    container: true\n  };\n\n  var mvhd = {\n    name: \"Movie Header Box\",\n    description: \"This box defines overall information which is \" + \"media‐independent, and relevant to the entire presentation \" + \"considered as a whole.\",\n    content: [{\n      name: \"version\",\n      description: \"mvhd version\",\n      key: \"version\"\n    }, {\n      name: \"flags\",\n      description: \"mvhd flags\",\n      key: \"flags\"\n    }, {\n      name: \"creation_time\",\n      description: \"An integer that declares the creation time of the \" + \"presentation (in seconds since midnight, Jan. 1, 1904, in UTC time)\",\n      key: \"creationTime\"\n    }, {\n      name: \"modification_time\",\n      description: \"An integer that declares the most recent time the \" + \"presentation was modified (in seconds since midnight, Jan. 1, 1904, \" + \"in UTC time)\",\n      key: \"modificationTime\"\n    }, {\n      name: \"timescale\",\n      description: \"An integer that specifies the time‐scale for the entire \" + \"presentation; this is the number of time units that pass in one second. \" + \"For example, a t me coordinate system that measures time in sixtieths \" + \"of a second has a time scale of 60.\",\n      key: \"timescale\"\n    }, {\n      name: \"duration\",\n      description: \"An integer that declares length of the presentation (in the \" + \"indicated timescale). This property is derived from the presentation’s \" + \"tracks: the value of this field corresponds to the duration of the \" + \"longest track in the presentation. If the durat ion cannot be \" + \"determined then duration is set to all 1s.\",\n      key: \"duration\"\n    }, {\n      name: \"rate\",\n      description: \"A fixed point 16.16 number that indicates the preferred \" + \"rate to play the presentation; 1.0 (0x00010000) is normal forward playback \",\n      key: \"rate\"\n    }, {\n      name: \"volume\",\n      description: \"A fixed point 8.8 number that indicates the preferred playback \" + \"volume. 1.0 (0x0100) is full volume.\",\n      key: \"volume\"\n    }, {\n      name: \"reserved 1\",\n      description: \"Reserved 16 bits\",\n      key: \"reserved1\"\n    }, {\n      name: \"reserved 2\",\n      description: \"Reserved 2*32 bits\",\n      key: \"reserved2\"\n    }, {\n      name: \"matrix\",\n      description: \"Provides a transformation matrix for the video; (u,v,w) are \" + \" restricted here to (0,0,1), hex values (0,0,0x40000000).\",\n      key: \"matrix\"\n    }, {\n      name: \"pre-defined\",\n      description: \"Pre-defined 32*6 bits.\",\n      key: \"predefined\"\n    }, {\n      name: \"next_track_ID\",\n      description: \"A non‐zero integer that indicates a value to use for the \" + \"track ID of the next track to be added to this presentation. \" + \"Zero is not a valid track ID value. The value of next_track_ID shall \" + \"be larger than the largest track‐ID in use. If this valu e is equal to \" + \"all 1s (32‐bit maxint), and a new media track is to be added, then a \" + \"search must be made in the file for an unused track identifier.\",\n      key: \"nextTrackId\"\n    }],\n    parser: function parser(reader) {\n      var version = reader.bytesToInt(1);\n\n      if (version > 1) {\n        throw new Error(\"invalid version\");\n      }\n\n      var flags = reader.bytesToInt(3);\n      var creationTime, modificationTime, timescale, duration;\n\n      if (version === 1) {\n        creationTime = reader.bytesToInt(8);\n        modificationTime = reader.bytesToInt(8);\n        timescale = reader.bytesToInt(4);\n        duration = reader.bytesToInt(8);\n      } else {\n        creationTime = reader.bytesToInt(4);\n        modificationTime = reader.bytesToInt(4);\n        timescale = reader.bytesToInt(4);\n        duration = reader.bytesToInt(4);\n      }\n\n      var rate = [reader.bytesToInt(2), reader.bytesToInt(2)].join(\".\");\n      var volume = [reader.bytesToInt(1), reader.bytesToInt(1)].join(\".\");\n      var reserved1 = reader.bytesToInt(2);\n      var reserved2 = [reader.bytesToInt(4), reader.bytesToInt(4)];\n      var matrixArr = [];\n\n      for (var i = 0; i < 9; i++) {\n        matrixArr.push(reader.bytesToInt(4));\n      }\n\n      var predefined = [reader.bytesToInt(4), reader.bytesToInt(4), reader.bytesToInt(4), reader.bytesToInt(4), reader.bytesToInt(4), reader.bytesToInt(4)];\n      var nextTrackId = reader.bytesToInt(4);\n      return {\n        version: version,\n        flags: flags,\n        creationTime: creationTime,\n        modificationTime: modificationTime,\n        timescale: timescale,\n        duration: duration,\n        rate: rate,\n        volume: volume,\n        reserved1: reserved1,\n        reserved2: reserved2,\n        matrix: matrixArr,\n        predefined: predefined,\n        nextTrackId: nextTrackId\n      };\n    }\n  };\n\n  var pdin = {\n    name: \"Progressive Download Information Box\",\n    description: \"\",\n    content: [{\n      name: \"version\",\n      description: \"pdin version\",\n      key: \"version\"\n    }, {\n      name: \"flags\",\n      description: \"pdin flags\",\n      key: \"flags\"\n    }, {\n      name: \"rate\",\n      description: \"Download rate expressed in bytes/second\",\n      key: \"rate\"\n    }, {\n      name: \"initial_delay\",\n      description: \"Suggested delay to use when playing the file, such \" + \"that if download continues at the given rate, all data within \" + \"the file will arrive in time for its use and playback should \" + \"not need to stall.\",\n      key: \"delay\"\n    }],\n    parser: function parser(reader) {\n      var version = reader.bytesToInt(1);\n\n      if (version !== 0) {\n        throw new Error(\"invalid version\");\n      }\n\n      return {\n        version: version,\n        flags: reader.bytesToInt(3),\n        rate: reader.bytesToInt(4),\n        delay: reader.bytesToInt(4)\n      };\n    }\n  };\n\n  var SYSTEM_IDS = {\n    \"1077EFECC0B24D02ACE33C1E52E2FB4B\": \"cenc\",\n    \"1F83E1E86EE94F0DBA2F5EC4E3ED1A66\": \"SecureMedia\",\n    \"35BF197B530E42D78B651B4BF415070F\": \"DivX DRM\",\n    \"45D481CB8FE049C0ADA9AB2D2455B2F2\": \"CoreCrypt\",\n    \"5E629AF538DA4063897797FFBD9902D4\": \"Marlin\",\n    \"616C7469636173742D50726F74656374\": \"AltiProtect\",\n    \"644FE7B5260F4FAD949A0762FFB054B4\": \"CMLA\",\n    \"69F908AF481646EA910CCD5DCCCB0A3A\": \"Marlin\",\n    \"6A99532D869F59229A91113AB7B1E2F3\": \"MobiDRM\",\n    \"80A6BE7E14484C379E70D5AEBE04C8D2\": \"Irdeto\",\n    \"94CE86FB07FF4F43ADB893D2FA968CA2\": \"FairPlay\",\n    \"992C46E6C4374899B6A050FA91AD0E39\": \"SteelKnot\",\n    \"9A04F07998404286AB92E65BE0885F95\": \"PlayReady\",\n    \"9A27DD82FDE247258CBC4234AA06EC09\": \"Verimatrix VCAS\",\n    \"A68129D3575B4F1A9CBA3223846CF7C3\": \"VideoGuard Everywhere\",\n    \"ADB41C242DBF4A6D958B4457C0D27B95\": \"Nagra\",\n    \"B4413586C58CFFB094A5D4896C1AF6C3\": \"Viaccess-Orca\",\n    \"DCF4E3E362F158187BA60A6FE33FF3DD\": \"DigiCAP\",\n    \"E2719D58A985B3C9781AB030AF78D30E\": \"ClearKey\",\n    \"EDEF8BA979D64ACEA3C827DCD51D21ED\": \"Widevine\",\n    \"F239E769EFA348509C16A903C6932EFB\": \"PrimeTime\"\n  };\n  var pssh = {\n    name: \"Protection System Specific Header\",\n    description: \"\",\n    parser: function parser(reader) {\n      var ret = {};\n      ret.version = reader.bytesToInt(1);\n\n      if (ret.version > 1) {\n        throw new Error(\"invalid version\");\n      }\n\n      ret.flags = reader.bytesToInt(3);\n      ret.systemID = reader.bytesToHex(16);\n      var systemIDName = SYSTEM_IDS[ret.systemID];\n\n      if (systemIDName) {\n        ret.systemID += \" (\".concat(systemIDName, \")\");\n      }\n\n      if (ret.version === 1) {\n        ret.KID_count = reader.bytesToInt(4);\n        ret.KIDs = [];\n        var i = ret.KID_count;\n\n        while (i--) {\n          ret.KIDs.push([reader.bytesToHex(16)]);\n        }\n      }\n\n      ret.data_length = reader.bytesToInt(4);\n      ret.data = reader.bytesToHex(ret.data_length);\n      return ret;\n    }\n  };\n\n  var saio = {\n    name: \"Sample Auxiliary Information Offsets\",\n    description: \"\",\n    parser: function parser(r) {\n      var ret = {};\n      ret.version = r.bytesToInt(1);\n      ret.flags = r.bytesToInt(3);\n\n      if (ret.flags == 1) {\n        ret.aux_info_type = r.bytesToInt(4);\n        ret.aux_info_type_parameter = r.bytesToInt(4);\n      }\n\n      ret.entry_count = r.bytesToInt(4);\n      ret.offset = [];\n      var i = ret.entry_count;\n\n      while (i--) {\n        ret.offset.push(r.bytesToInt(ret.version == 0 ? 4 : 8));\n      }\n\n      return ret;\n    }\n  };\n\n  var saiz = {\n    name: \"Sample Auxiliary Information Sizes\",\n    description: \"\",\n    parser: function parser(r) {\n      var ret = {};\n      ret.version = r.bytesToInt(1);\n      ret.flags = r.bytesToInt(3);\n\n      if (ret.flags == 1) {\n        ret.aux_info_type = r.bytesToInt(4);\n        ret.aux_info_type_parameter = r.bytesToInt(4);\n      }\n\n      ret.default_sample_info_size = r.bytesToInt(1);\n      ret.sample_count = r.bytesToInt(4);\n\n      if (ret.default_sample_info_size == 0) {\n        ret.sample_info_size = [];\n        var i = ret.sample_count;\n\n        while (i--) {\n          ret.sample_info_size.push(r.bytesToInt(1));\n        }\n      }\n\n      return ret;\n    }\n  };\n\n  var sdtp = {\n    name: \"Independent and Disposable Samples Box\",\n    description: \"\",\n    parser: function parser(r) {\n      var ret = {\n        version: r.bytesToInt(1),\n        flags: r.bytesToInt(3)\n      };\n      var remaining = r.getRemainingLength();\n      var i = remaining;\n      ret.samples = [];\n\n      while (i--) {\n        var _byte = r.bytesToInt(1);\n\n        ret.samples.push({\n          is_leading: _byte >> 6 & 0x03,\n          sample_depends_on: _byte >> 4 & 0x03,\n          sample_is_depended_on: _byte >> 2 & 0x03,\n          sample_has_redundancy: _byte & 0x03\n        });\n      }\n\n      return ret;\n    }\n  };\n\n  var sidx = {\n    name: \"Segment Index Box\",\n    description: \"Index of the media stream\",\n    parser: function parser(r) {\n      var version = r.bytesToInt(1);\n      var flags = r.bytesToInt(3);\n      var reference_id = r.bytesToInt(4);\n      var timescale = r.bytesToInt(4);\n      var earliest_presentation_time = r.bytesToInt(version === 0 ? 4 : 8);\n      var first_offset = r.bytesToInt(version === 0 ? 4 : 8);\n      var reserved = r.bytesToInt(2);\n      var reference_count = r.bytesToInt(2);\n      var items = [];\n      var i = reference_count;\n\n      while (i--) {\n        var first4Bytes = r.bytesToInt(4);\n        var second4Bytes = r.bytesToInt(4);\n        var third4Bytes = r.bytesToInt(4);\n        items.push({\n          reference_type: first4Bytes >> 31 & 0x01,\n          referenced_size: first4Bytes & 0x7FFFFFFF,\n          subsegment_duration: second4Bytes,\n          starts_with_SAP: third4Bytes >> 31 & 0x01,\n          SAP_type: third4Bytes >> 28 & 0x07,\n          SAP_delta_time: third4Bytes & 0x0FFFFFFF\n        });\n      }\n\n      return {\n        version: version,\n        flags: flags,\n        reference_id: reference_id,\n        timescale: timescale,\n        earliest_presentation_time: earliest_presentation_time,\n        first_offset: first_offset,\n        reserved: reserved,\n        reference_count: reference_count,\n        items: items\n      };\n    }\n  };\n\n  var skip = {\n    name: \"Free Space Box\",\n    description: \"This box can be completely ignored.\"\n  };\n\n  var stbl = {\n    name: \"Sample Table\",\n    description: \"\",\n    container: true\n  };\n\n  var stco = {\n    name: \"Chunk Offset\",\n    description: \"\",\n    parser: function parser(r) {\n      var ret = {};\n      ret.version = r.bytesToInt(1);\n      ret.flags = r.bytesToInt(3);\n      ret.entry_count = r.bytesToInt(4);\n      ret.chunk_offsets = [];\n      var i = ret.entry_count;\n\n      while (i--) {\n        ret.chunk_offsets.push(r.bytesToInt(4));\n      }\n\n      return ret;\n    }\n  };\n\n  var stsc = {\n    name: \"Sample To Chunk\",\n    description: \"\",\n    parser: function parser(r) {\n      var ret = {};\n      ret.version = r.bytesToInt(1);\n      ret.flags = r.bytesToInt(3);\n      ret.entry_count = r.bytesToInt(4);\n      ret.entries = [];\n      var i = ret.entry_count;\n\n      while (i--) {\n        var e = {};\n        e.first_chunk = r.bytesToInt(4);\n        e.samples_per_chunk = r.bytesToInt(4);\n        e.sample_description_index = r.bytesToInt(4);\n        ret.entries.push(e);\n      }\n\n      return ret;\n    }\n  };\n\n  var stsd = {\n    name: \"Sample Description\",\n    description: \"Information about the coding type used\",\n    parser: function parser(r) {\n      var ret = {};\n      ret.version = r.bytesToInt(1);\n      ret.flags = r.bytesToInt(3);\n      ret.entry_count = r.bytesToInt(4);\n      return ret;\n    },\n    container: true\n  };\n\n  var stsz = {\n    name: \"Sample Size\",\n    description: \"\",\n    parser: function parser(r) {\n      var ret = {};\n      ret.version = r.bytesToInt(1);\n      ret.flags = r.bytesToInt(3);\n      ret.sample_size = r.bytesToInt(4);\n      ret.sample_count = r.bytesToInt(4);\n\n      if (ret.sample_size == 0) {\n        ret.entries = [];\n        var i = ret.sample_count;\n\n        while (i--) {\n          ret.entries.push(r.bytesToInt(4));\n        }\n      }\n\n      return ret;\n    }\n  };\n\n  var stts = {\n    name: \"Decoding Time to Sample\",\n    description: \"\",\n    parser: function parser(r) {\n      var ret = {};\n      ret.version = r.bytesToInt(1);\n      ret.flags = r.bytesToInt(3);\n      ret.entry_count = r.bytesToInt(4);\n      ret.entries = [];\n      var i = ret.entry_count;\n\n      while (i--) {\n        var e = {};\n        e.sample_count = r.bytesToInt(4);\n        e.sample_delta = r.bytesToInt(4);\n        ret.entries.push(e);\n      }\n\n      return ret;\n    }\n  };\n\n  var styp = {\n    name: \"Segment Type Box\",\n    description: \"\",\n    content: ftyp.content,\n    parser: ftyp.parser\n  };\n\n  var tfdt = {\n    name: \"Track Fragment Decode Time\",\n    description: \"The absolute decode time, measured on the media timeline, of \" + \"the first sample in decode order in the track fragment\",\n    parser: function parser(r) {\n      var version = r.bytesToInt(1);\n      return {\n        version: version,\n        flags: r.bytesToInt(3),\n        baseMediaDecodeTime: r.bytesToInt(version ? 8 : 4)\n      };\n    }\n  };\n\n  var tfhd = {\n    name: \"Track Fragment Header Box\",\n    description: \"\",\n    parser: function parser(r) {\n      var ret = {};\n      ret.version = r.bytesToInt(1);\n      var flags = r.bytesToInt(3);\n      var hasBaseDataOffset = flags & 0x000001;\n      var hasSampleDescriptionIndex = flags & 0x000002;\n      var hasDefaultSampleDuration = flags & 0x000008;\n      var hasDefaultSampleSize = flags & 0x000010;\n      var hasDefaultSampleFlags = flags & 0x000020;\n      var durationIsEmpty = flags & 0x010000;\n      var defaultBaseIsMOOF = flags & 0x020000;\n      ret.flags = {\n        \"base-data-offset-present\": !!hasBaseDataOffset,\n        \"sample-description-index-present\": !!hasSampleDescriptionIndex,\n        \"default-sample-duration-present\": !!hasDefaultSampleDuration,\n        \"default-sample-size-present\": !!hasDefaultSampleSize,\n        \"default-sample-flags-present\": !!hasDefaultSampleFlags,\n        \"duration-is-empty\": !!durationIsEmpty,\n        \"default-base-is-moof\": !!defaultBaseIsMOOF\n      };\n      ret.track_ID = r.bytesToInt(4);\n\n      if (hasBaseDataOffset) {\n        ret.base_data_offset = r.bytesToInt(8);\n      }\n\n      if (hasSampleDescriptionIndex) {\n        ret.sample_description_index = r.bytesToInt(4);\n      }\n\n      if (hasDefaultSampleDuration) {\n        ret.default_sample_duration = r.bytesToInt(4);\n      }\n\n      if (hasDefaultSampleSize) {\n        ret.default_sample_size = r.bytesToInt(4);\n      }\n\n      if (hasDefaultSampleFlags) {\n        ret.default_sample_flags = r.bytesToInt(4);\n      }\n\n      return ret;\n    }\n  };\n\n  var tkhd = {\n    name: \"Track Header Box\",\n    description: \"Characteristics of a single track.\",\n    parser: function parser(r) {\n      var version = r.bytesToInt(1);\n      return {\n        version: version,\n        flags: r.bytesToInt(3),\n        creation_time: r.bytesToInt(version ? 8 : 4),\n        modification_time: r.bytesToInt(version ? 8 : 4),\n        track_ID: r.bytesToInt(4),\n        reserved1: r.bytesToInt(4),\n        duration: r.bytesToInt(version ? 8 : 4),\n        reserved2: [r.bytesToInt(4), r.bytesToInt(4)],\n        // TODO template? signed?\n        layer: r.bytesToInt(2),\n        alternate_group: r.bytesToInt(2),\n        volume: [r.bytesToInt(1), r.bytesToInt(1)].join(\".\"),\n        reserved3: r.bytesToInt(2),\n        matrix: [r.bytesToInt(4), r.bytesToInt(4), r.bytesToInt(4), r.bytesToInt(4), r.bytesToInt(4), r.bytesToInt(4), r.bytesToInt(4), r.bytesToInt(4), r.bytesToInt(4)],\n        width: [r.bytesToInt(2), r.bytesToInt(2)],\n        height: [r.bytesToInt(2), r.bytesToInt(2)]\n      };\n    }\n  };\n\n  var traf = {\n    name: \"Track Fragment Box\",\n    description: \"\",\n    container: true\n  };\n\n  var trak = {\n    name: \"Track Box\",\n    description: \"Container box for a single track of a presentation. \" + \"A presentation consists of one or more tracks. Each track is independent \" + \"of the other tracks in the presentation and carries its own temporal and \" + \"spatial information. Each track will contain its associated Media Box.\",\n    container: true\n  };\n\n  var trex = {\n    name: \"Track Extends Box\",\n    description: \"sets up default values used by the movie fragments. \" + \"By setting defaults in this way, space and complexity can be saved \" + \"in each Track Fragment Box\",\n    parser: function parser(reader) {\n      return {\n        version: reader.bytesToInt(1),\n        flags: reader.bytesToInt(3),\n        \"track_id\": reader.bytesToInt(4),\n        \"default_sample_description_index\": reader.bytesToInt(4),\n        \"default_sample_duration\": reader.bytesToInt(4),\n        \"default_sample_size\": reader.bytesToInt(4),\n        \"default_sample_flags\": reader.bytesToInt(4)\n      };\n    }\n  };\n\n  var trun = {\n    name: \"Track Fragment Run Box\",\n    parser: function parser(r) {\n      var ret = {};\n      ret.version = r.bytesToInt(1);\n      var flags = r.bytesToInt(3);\n      var hasDataOffset = flags & 0x000001;\n      var hasFirstSampleFlags = flags & 0x000004;\n      var hasSampleDuration = flags & 0x000100;\n      var hasSampleSize = flags & 0x000200;\n      var hasSampleFlags = flags & 0x000400;\n      var hasSampleCompositionOffset = flags & 0x000800;\n      ret.flags = {\n        \"data-offset-present\": !!hasDataOffset,\n        \"first-sample-flags-present\": !!hasFirstSampleFlags,\n        \"sample-duration-present\": !!hasSampleDuration,\n        \"sample-size-present\": !!hasSampleSize,\n        \"sample-flags-present\": !!hasSampleFlags,\n        \"sample-composition-time-offset-present\": !!hasSampleCompositionOffset\n      };\n      ret.sample_count = r.bytesToInt(4); // two's complement\n\n      if (hasDataOffset) {\n        ret.data_offset = ~~r.bytesToInt(4);\n      }\n\n      if (hasFirstSampleFlags) {\n        ret.first_sample_flags = r.bytesToInt(4);\n      }\n\n      var i = ret.sample_count;\n      ret.samples = [];\n\n      while (i--) {\n        var sample = {};\n\n        if (hasSampleDuration) {\n          sample.sample_duration = r.bytesToInt(4);\n        }\n\n        if (hasSampleSize) {\n          sample.sample_size = r.bytesToInt(4);\n        }\n\n        if (hasSampleFlags) {\n          sample.sample_flags = r.bytesToInt(4);\n        }\n\n        if (hasSampleCompositionOffset) {\n          sample.sample_composition_time_offset = ret.version === 0 ? r.bytesToInt(4) : ~~r.bytesToInt(4);\n        }\n\n        ret.samples.push(sample);\n      }\n\n      return ret;\n    }\n  };\n\n  var url_ = {\n    name: \"Data Entry Url Box\",\n    description: \"declare the location(s) of the media data used within the presentation.\",\n    parser: function parser(r) {\n      var ret = {};\n      ret.version = r.bytesToInt(1);\n      ret.flags = r.bytesToInt(3);\n      var remaining = r.getRemainingLength();\n\n      if (remaining) {\n        ret.location = String.fromCharCode.apply(String, r.bytesToInt(r.getRemainingLength()));\n      }\n\n      return ret;\n    }\n  };\n\n  var urn_ = {\n    name: \"Data Entry Url Box\",\n    description: \"declare the location(s) of the media data used within the presentation.\",\n    parser: function parser(r) {\n      var ret = {};\n      ret.version = r.bytesToInt(1);\n      ret.flags = r.bytesToInt(3);\n      var remaining = r.getRemainingLength(); // TODO Check NULL-terminated stream for name+location\n      // might also check flags for that\n\n      if (remaining) {\n        ret.name = String.fromCharCode.apply(String, r.bytesToInt(r.getRemainingLength()));\n      }\n\n      return ret;\n    }\n  };\n\n  var uuid = {\n    name: \"User-defined Box\",\n    description: \"Custom box. Those are not yet parsed here.\"\n  };\n\n  var vmhd = {\n    name: \"Video Media Header\",\n    description: \"The video media header contains general presentation \" + \"information, independent of the coding, for video media.\",\n    parser: function parser(reader) {\n      var version = reader.bytesToInt(1);\n      var flags = reader.bytesToInt(3);\n\n      if (version !== 0) {\n        throw new Error(\"invalid version\");\n      }\n\n      if (flags !== 1) {\n        throw new Error(\"invalid flags\");\n      } // TODO template?\n\n\n      var graphicsmode = reader.bytesToInt(2);\n      var opcolor = [reader.bytesToInt(2), reader.bytesToInt(2), reader.bytesToInt(2)];\n      return {\n        version: version,\n        flags: flags,\n        graphicsmode: graphicsmode,\n        opcolor: opcolor\n      };\n    }\n  };\n\n  var definitions = {\n    dinf: dinf,\n    dref: dref,\n    edts: edts,\n    free: free,\n    ftyp: ftyp,\n    hdlr: hdlr,\n    iods: iods,\n    leva: leva,\n    mdat: mdat,\n    mdhd: mdhd,\n    mdia: mdia,\n    mehd: mehd,\n    mfhd: mfhd,\n    minf: minf,\n    moof: moof,\n    moov: moov,\n    mvex: mvex,\n    mvhd: mvhd,\n    pdin: pdin,\n    pssh: pssh,\n    saio: saio,\n    saiz: saiz,\n    sdtp: sdtp,\n    sidx: sidx,\n    skip: skip,\n    stbl: stbl,\n    stco: stco,\n    stsc: stsc,\n    stsd: stsd,\n    stsz: stsz,\n    stts: stts,\n    styp: styp,\n    tfdt: tfdt,\n    tfhd: tfhd,\n    tkhd: tkhd,\n    traf: traf,\n    trak: trak,\n    trex: trex,\n    trun: trun,\n    \"url \": url_,\n    \"urn \": urn_,\n    uuid: uuid,\n    vmhd: vmhd\n  };\n\n  /**\n   * Parse recursively ISOBMFF Uint8Array.\n   * @param {Uint8Array} arr\n   * @returns {Array.<Object>}\n   */\n\n  function recursiveParseBoxes(arr) {\n    var i = 0;\n    var returnedArray = [];\n\n    var _loop = function _loop() {\n      var currentOffset = i;\n      var size = be4toi(arr, currentOffset);\n      currentOffset += 4;\n\n      if (size === 1) {\n        size = be8toi(arr, currentOffset);\n        currentOffset += 8;\n      } else if (size === 0) {\n        size = arr.length - i;\n      }\n\n      var name = betoa(arr, currentOffset, 4);\n      currentOffset += 4;\n      var atomObject = {\n        alias: name,\n        size: size,\n        values: []\n      };\n\n      if (name === \"uuid\") {\n        var subtype = [];\n        var j = 16;\n\n        while (j--) {\n          subtype.push(arr[currentOffset]);\n          currentOffset += 1;\n        }\n\n        atomObject.subtype = subtype;\n      }\n\n      returnedArray.push(atomObject);\n\n      if (definitions[name]) {\n        var config = definitions[name];\n        var contentInfos = config.content ? config.content.reduce(function (acc, el) {\n          acc[el.key] = {\n            name: el.name || \"\",\n            description: el.description | \"\"\n          };\n          return acc;\n        }, {}) : {\n          name: \"\",\n          description: \"\"\n        };\n        atomObject.name = config.name || \"\";\n        atomObject.description = config.description || \"\";\n        var hasChildren = !!config.container;\n        var content = arr.slice(currentOffset, size + i);\n        var contentForChildren;\n\n        if (typeof config.parser === \"function\") {\n          var parserReader = createBufferReader(content);\n          var result = {};\n\n          try {\n            result = config.parser(parserReader);\n          } catch (e) {\n            console.warn(\"impossible to parse \\\"\".concat(name, \"\\\" box.\"), e);\n          }\n\n          if (hasChildren) {\n            var remaining = parserReader.getRemainingLength();\n            contentForChildren = content.slice(content.length - remaining);\n          } else if (!parserReader.isFinished()) {\n            console.warn(\"not everything has been parsed for box: \" + name + \". Missing\", parserReader.getRemainingLength(), \"bytes.\");\n          }\n\n          delete result.__data__;\n          Object.keys(result).forEach(function (key) {\n            var infos = contentInfos[key] || {};\n\n            if (!infos.name) {\n              infos.name = key;\n            }\n\n            atomObject.values.push(Object.assign({\n              value: result[key]\n            }, infos));\n          });\n        }\n\n        if (hasChildren) {\n          var childrenResult = parseBoxes(contentForChildren || content);\n          atomObject.children = childrenResult;\n        }\n      }\n\n      i += size;\n    };\n\n    while (i < arr.length) {\n      _loop();\n    }\n\n    return returnedArray;\n  }\n  /**\n   * Parse ISOBMFF file and translate it into a more useful array containing\n   * \"atom objects\".\n   * @param {ArrayBuffer|Uint8Array} arr\n   * @returns {Array.<Object>}\n   */\n\n\n  function parseBoxes(arr) {\n    if (arr instanceof Uint8Array) {\n      return recursiveParseBoxes(arr);\n    }\n\n    if (arr instanceof ArrayBuffer) {\n      return recursiveParseBoxes(new Uint8Array(arr));\n    }\n\n    if (arr.buffer instanceof ArrayBuffer) {\n      return recursiveParseBoxes(new Uint8Array(arr.buffer));\n    }\n\n    throw new Error(\"Unrecognized format. \" + \"Please give an ArrayBuffer or TypedArray instead.\");\n  }\n\n  return parseBoxes;\n\n}));\n\n\n//# sourceURL=webpack://aisobmffwvdfbutfaii/./node_modules/isobmff-inspector/dist/bundle.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var isobmff_inspector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! isobmff-inspector */ \"./node_modules/isobmff-inspector/dist/bundle.js\");\n/* harmony import */ var isobmff_inspector__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(isobmff_inspector__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _renderer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./renderer.js */ \"./src/renderer.js\");\n\n\n\n// -- Feature switching based on the various API support --\n\nif (window.File && window.FileReader && window.Uint8Array) {\n\n  /**\n   * @param {Event} evt\n   * @returns {Boolean}\n   */\n  function onFileSelection(evt) {\n    const files = evt.target.files; // FileList object\n\n    if (!files.length) {\n      return;\n    }\n\n    const file = files[0];\n    const reader = new FileReader();\n\n    // TODO read progressively to skip mdat and whatnot\n    reader.onload = (evt) => {\n      const arr = new Uint8Array(evt.target.result);\n      const res = isobmff_inspector__WEBPACK_IMPORTED_MODULE_0___default()(arr);\n      (0,_renderer_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(res);\n    };\n\n    reader.readAsArrayBuffer(file);\n    return false;\n  }\n\n  document.getElementById(\"file-input\")\n    .addEventListener(\"change\", onFileSelection, false);\n\n} else {\n  const localSegmentInput = document.getElementById(\"choices-local-segment\");\n  localSegmentInput.style.display = \"none\";\n\n  const choiceSeparator = document.getElementById(\"choices-separator\");\n  choiceSeparator.style.display = \"none\";\n}\n\nif (window.fetch && window.Uint8Array) {\n\n  /**\n   * @param {Event} evt\n   */\n  function onUrlValidation(url) {\n    fetch(url)\n      .then(response => response.arrayBuffer())\n      .then((arrayBuffer) => {\n        const parsed = isobmff_inspector__WEBPACK_IMPORTED_MODULE_0___default()(new Uint8Array(arrayBuffer));\n        (0,_renderer_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(parsed);\n      });\n  }\n\n  /**\n   * @returns {Boolean}\n   */\n  function onButtonClicking() {\n    const url = document.getElementById(\"url-input\").value;\n    if (url) {\n      onUrlValidation(url);\n      return false;\n    }\n  }\n\n  /**\n   * @param {Event} evt\n   * @returns {Boolean}\n   */\n  function onInputKeyPress(evt) {\n    const keyCode = evt.keyCode || evt.which;\n    if (keyCode == 13) {\n      const url = evt.target.value;\n      if (url) {\n        onUrlValidation(url);\n      }\n      return false;\n    }\n  }\n\n  document.getElementById(\"url-input\")\n    .addEventListener(\"keypress\", onInputKeyPress, false);\n\n  document.getElementById(\"url-button\")\n    .addEventListener(\"click\", onButtonClicking, false);\n} else {\n  const choiceSeparator = document.getElementById(\"choices-separator\");\n  choiceSeparator.style.display = \"none\";\n\n  const urlSegmentInput = document.getElementById(\"choices-url-segment\");\n  urlSegmentInput.style.display = \"none\";\n}\n\n\n//# sourceURL=webpack://aisobmffwvdfbutfaii/./src/index.js?");

/***/ }),

/***/ "./src/renderer.js":
/*!*************************!*\
  !*** ./src/renderer.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst wrapper = document.getElementById(\"file-description\");\n\nconst sanitize = (str) => {\n  const div = document.createElement(\"div\");\n  div.appendChild(document.createTextNode(str));\n  return div.innerHTML;\n};\n\nconst title = () => {\n  return `\n    <h2 id=\"result-title\">Results</h2>\n  `;\n};\n\nconst getObjectDisplay = (obj) => {\n  const props = Object.keys(obj).map(key =>\n    `\n      <div class=\"value-object-prop\">\n        <span class=\"value-object-key\">${sanitize(key)}</span>:\n        <span class=\"value-object-value\">${getValueToDisplay(obj[key])}</span>\n      </div>\n    `,\n  ).join(\"\");\n  return `\n    <div class=\"value-object-line\">\n      ${props}\n    </div>\n  `;\n};\n\nconst getValueToDisplay = (val) => {\n  if (val == null) {\n    return undefined;\n  }\n  switch (typeof val) {\n  case \"object\":\n    if (Array.isArray(val)) {\n      if (!val.length) {\n        return \"no element\";\n      }\n      if (typeof val[0] === \"number\") {\n        return val.join(\" \");\n      }\n      return val.map(getObjectDisplay).join(\" \");\n    }\n\n    return getObjectDisplay(val);\n  case \"string\":\n    return `\"${sanitize(val)}\"`;\n  }\n\n  return sanitize(val);\n};\n\nconst BoxTitle = (box) =>\n  `\n    <div class=\"box-title\">\n      <span class=\"box-name\">${sanitize(box.name)}</span>\n      <span class=\"box-alias\">(\"${sanitize(box.alias)}\")</span>\n      <span class=\"box-size\">${sanitize(box.size)} bytes</span>\n    </div>\n  `;\n\nconst BoxDescription = (box) =>\n  `\n    <div class=\"box-description\">\n      ${sanitize(box.description)}\n    </div>\n  `;\n\nconst BoxValue = (value) => {\n  return `\n    <div class=\"box-value-entry\">\n      <span class=\"box-value-key\">${sanitize(value.name)}</span>:\n      <span class=\"box-value-value\">${getValueToDisplay(value.value)}</span>\n    </div>\n  `;\n};\n\nconst BoxValues = (box) =>\n  (box.values || []).map(v => BoxValue(v)).join(\"\");\n\nconst Box = (box) => {\n  const children = (box.children || []).map(Box).join(\"\");\n  return `\n    <div class=\"box\">\n      ${BoxTitle(box)}\n      ${BoxDescription(box)}\n      ${BoxValues(box)}\n      ${children}\n    </div>\n  `;\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((arr = []) => {\n  console.log(\"rendering...\", arr);\n  wrapper.style.display = \"none\";\n  wrapper.innerHTML =  title() + arr.map(Box).join(\"\");\n  wrapper.style.display = \"block\";\n});\n\n\n//# sourceURL=webpack://aisobmffwvdfbutfaii/./src/renderer.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;